關於語言和演算法的註釋B關於語言和演算法的註釋B
B.1

 用 Backus-Naur Form(BNF)定義語言

在本書中我們定義了幾種語言，包括命題邏輯(第 
7章)、一階邏輯(第 
8章)，以及英文的
一個子集合(第 
23章)。正規語言被定義為一個字串集合，其中每個字串都是一個符號序列。我們
感興趣的語言是由一個含有無限多個字串的集合構成，因此我們需要一種簡潔的方法來描述這個集
合的特徵。這是透過文法(grammar)實作的。我們使用的特別文法稱為語境自由文法 
(context-free 
grammer)，因為每個表達式在任何語境中都有相同形式。我們用一種稱為 
Backus-Naur Form(BNF)
的正規表示法來寫文法。BNF文法包含 
4個部分： 


● 
一組終端符號。這些是構成語言字串的符號或詞。它們可能是字母 
(A,B,C,...)或者單詞 
(a,aardvark,abacus,...)，或任何適於該領域之符號。 
● 
一組非終端符號，它們對語言中的子片語 
(subphrase)加以分類。例如，英語中的非終端符號 
NounPhrase(名詞片語)表示字串的一個無限集合，包括「 
you(你)」和「the big slobbery dog(這隻
邋遢的大狗)」。 
● 
一個起始符號，即一非終端符號其表示語言字串的完整集合。在英語中，這是 
Sentence(句子)；
在算術中，可能是 
Expr(運算式)，而在程式語言中，是 
Program(程式)。 
● 
一組重寫規則，具有 
LHS→RHS的形式，其中 
LHS是一個非終端符號，而 
RHS則是由零個或
更多符號所構成的一個序列。這些符號可以是終端或非終端符號，或是符號 
ε 
(即代表空字串)。
一條具有以下形式的重寫規則 


Sentence → NounPhrase VerbPhrase
意味著只要我們有了 
NounPhrase和 
VerbPhrase這兩類字串，我們就可以把二者連接在一起，並將
所得結果歸入 
Sentence的類別。簡寫時，(S → A)及(S → B)這兩個規則可寫為(S → A | B)。
下面是簡單算術運算式的一個 
BNF語法： 
Expr → 
Expr Operator Expr |( Expr ) | Number 
Number → 
Digit | Number Digit 
Digit → 
0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
Operator → 
+ | .| ÷ | ×
在第 
22章中我們更詳細地探討了語言和文法。注意其他書籍使用的 
BNF標記法可能稍有不同；
例如，你可能會看到用 
Digit


而非 
Digit表示一個非終端符號，用 
‘word’而非 
word表示一個終端符
號，或者用: :=而非→定義一條規則。 



附錄 


.App-9. 
用虛擬碼描述演算法

本書演算法是以虛擬碼來描述。大部分的虛擬碼對於使用像 
Java、C++及 
LISP這幾種語言的人
應該是很熟悉的。在一些描述起來比較煩瑣的部分，我們也使用數學公式或者普通的英語。不過幾
個特別地方需要註明。 


● 
靜態變數(Persistent variables)：我們使用關鍵字 
persistent來表示一個變數在函數第一次呼叫時
得到其初始值，並且在所有對該函數的後續呼叫中都保持該值 
(或後續的賦值句所指定的值)。因
此，靜態變數就像全域變數，因為生存期超過了對其所屬函數的單一呼叫，然而只有在函數內
部才能存取它們。本書中的代理人程式把靜態變數用於「記憶」。在像 
C++、Java、Python和 
Smalltalk這樣的物件導向語言中，包含靜態變數的程式可以實作成「物件」。在函數語言中，
它們也可以在包含所需變數的環境中由函數封裝(functional closures)來實作。 
● 
作為變數值的函數。函數和程序使用大寫名稱，而變數則使用斜體小寫名稱。所以大部分情況
下，函數呼叫看起來類似於 
FN(x)。然而，我們允許變數的值是一個函數；例如，如果變數 
f的
值是平方根函數，那麼 
f (9)回傳 
3。 
● 
for each：「for each x in c do」這個記法代表迴圈以變數 
x執行，且 
x限於集合 
c中連續的元素 
(successive elements)。 
● 
縮排很重要：和在 
Python語言中一樣，本書用縮排來標識迴圈和條件式的範圍。這和 
Java及 
C++(兩者使用大括弧)，或者 
Pascal及 
Visual Basic(兩者使用 
end)等都不一樣。 
● 
解構賦值(Destructuring assignment)：「x,y ← pair」記法代表右側需求算為兩元素值組，而第一
個元素被指定至 
x，第二個至 
y。相同概念也用於「for each x,y in pairs do」，且可用於交換兩
變數：“x,y ← 
y,x” 
● 
Generators及 
yield：「generator G(x) yields numbers」之符號將 
G定義為產生器函數。用個例
子即可充分理解。圖 
B.1所示的一段程式碼會打出數字 
1, 2, 4,…，且不會停。對 
POWERS-OF-2
的呼叫會回傳一個 
generator，其於每次迴圈碼要求集合下一元素時產生一值。雖然集合為無限，
一次計數一元素。
圖 B.1產生器函數的例子，及其於迴圈內的調用 (invocation) 


.App-10..App-10.
人工智慧 
–現代方法 
3/E 


● 
數列(Lists)：[x, y, z]代表三個元素形成的一數列。[first | rest]表示之數列為將 
first加進數列 
rest
後所得。在 
Lisp中，這是 
cons函數。 
● 
集合(Sets)：{x , y, z}表示三個元素形成之集合。{x: p(x)}代表使 
p(x)為真之所有元素 
x。 
● 
陣列下標從 
1起始。除非明確聲明，否則陣列的第一個下標是 
1 (如同通常的數學符號一樣)，而
不是像在 
Java和 
C中為 
0。 
線上協助 

本書中的大部分演算法都已經在我們的線上程式碼庫中實作(以 
Java，Lisp及 
Python)： 


aima.cs.berkeley.edu

上述官網也包括許多說明：如何回饋意見、修正、改進本書之建議，以及如何加入討論串。


