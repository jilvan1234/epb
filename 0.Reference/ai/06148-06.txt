6CONSTRAINT SATISFACTION PROBLEMS 
限制滿足問題 
6CONSTRAINT SATISFACTION PROBLEMS 
限制滿足問題 
本章中我們會看到不把狀態僅僅當作小黑盒子時，會如何引導設計出更強有力的新搜
尋方法，以及對問題的結構和複雜性有更深的理解。

第三章和第四章探索了透過搜尋狀態空間求解問題的想法。這些狀態可以透過特定值域的啟發
式演算法加以評價，並且測試它們是否為目標狀態。然而，從搜尋演算法的觀點看，每個狀態都原
子的，或不可分的——是一個無內在結構的黑盒子。

本章描述一種更有效率的方式來求解各式各樣的問題。我們使用每個狀態的因式表示法：一個
變數集，集合中的每個變數都有一個值。當每個變數都有一個值能滿足所有加諸於該變數的限制，
該問題就算被解出。以這樣的方式被描述的問題稱之為限制滿足問題，或 
CSP。 


CSP搜尋演算法利用狀態結構的優勢並使用一般性的而非問題特定的啟發式來使複雜問題的解
答變得可能。主要的構想是經由辨識出那些違反限制的變數/值之組合來一次大量削減搜尋空間。 


6.1

限制滿足問題的定義 

一個限制滿足問題由 
X、D、C三個成份所組成： 


X是一個變數{X1, …, Xn}的集合。 
D是一個值域{D1,…, Dn}的集合，每個變數各有一個。 
C是一個限制的集合，指明值可允許的組合方式。


每個值域 
Di是由變數 
Xi可允許的值{v1, …, vk}之集合所組成。每個限制 
Ci由.scope, rel.對所組成，
其中 
scope是參與限制的變數之元組，而 
rel是定義變數能賦予哪些值的關係。關係可以用一張明列
出所有滿足該限制之值的元組的名單來代表，或是以一個抽象關係來代表，該關係支援兩個操作：
測試元組是否為該關係的成員，以及列舉該關係的成員。舉例來說，如果 
X1與 
X2都有值域{A, B}，
那麼兩個變數必須有不同值的限制可以被寫為.(X1, X2), [(A, B), (B, A)].或為. 
(X1, X2), X1 ≠ 
X2.。

欲求解一個 
CSP，我們必須定義一個狀態空間與一個解的符號。CSP中的每個狀態定義為一些
或是所有變數的賦值，{Xi = vi, Xj = vj, …}。一個不違反任何限制條件的賦值，稱作相容的或者合法
的賦值。完全賦值是讓每個變數有賦值，而 
CSP問題的解是一個一致的完全賦值。不完全賦值指的
是僅僅設定值予某些變數。


.6-2..6-2.
人工智慧 
–現代方法 
3/E 


6.1.1範例問題：地圖著色 
(a) (b)
圖 6.1 (a) 澳大利亞主要的州和地方行政區。對此地圖的著色可以視為一個限制滿足問題。目標是對每
個區域分配顏色，使得相鄰的區域不同色。 (b) 表示地圖著色問題的限制圖

假設，厭倦了羅馬尼亞，我們看看展示澳洲各州以及其領土的地圖 
(圖 
6.1a)。我們被交付的任務
是為每個地域塗上顏色，可以是紅色，綠色，或藍色，著色的條件是兩個相鄰的區域不能塗上同樣
的顏色。要將這個題目改寫成一個 
CSP問題，我們將各區域定義成變數 


X = {WA, NT, Q, NSW, V, SA, T }
每個變數的值域是集合 
Di = {red, green, blue}(即紅綠藍三色)。限制是要求隔鄰的區域要有不同的顏
色。因為有九個地方是彼此交界的，所以有九個限制： 


C = {SA≠WA, SA≠NT, SA≠Q, SA≠NSW, SA≠V, WA≠NT, NT≠Q, Q≠NSW, NSW≠V }
這裡使用縮寫；SA≠WA是.(SA, WA), SA≠WA.的簡寫，其中 
SA≠WA能夠被完整地逐一地列出如 


{(red, green), (red, blue), (green, red), (green, blue), (blue, red), (blue, green)}
這個問題有很多可能的解，如： 


{WA = red, NT = green, Q = red, NSW = green, V = red, SA = blue, T = red}
把 
CSP視覺化地表示為限制圖是有用的，如圖 
6.1(b)所示。圖的節點對應於此問題的變數，一個連
接將兩個參與某個限制的變數連在一起。
為什麼要將一個問題公式化為一個 
CSP問題？一個原因是 
CSP 對許多類型的問題能得到很自

然的表示；如果你已經有一個 CSP求解系統，使用它來求解一個問題較諸使用另一個搜尋技術來設
計個定製的答案來得容易。除此之外， 
CSP 求解器的速度比狀態空間搜尋器來的快，因為 
CSP求解
器能快速地消除大塊的搜尋空間。舉例來說，一旦在澳洲問題中我們已經選擇 
{SA= blue}，我們能得

到的結論是五個相鄰之變數無一能夠為藍色。如果沒有利用到限制傳播的好處，則搜尋程序必須考
慮這五個相鄰變數的 
35 = 243種賦值；有了限制的傳播我們就不必將藍色列入考慮，所以我們只需
要檢查 
25 = 32個賦值，減少了 
87%。


Ch6限制滿足問題 


.6-3. 
於正常的狀態空間搜尋我們只能問：這個特定的狀態是目標嗎？不是？那麼這個呢？有了 
CSP，一旦我們發現某個部分賦值不是解答的時候，我們能夠立即將之拋棄進而調整該不完全賦值。
進而，我們能看出為什麼該賦值不是解答 ——我們看看哪一個變數違背了限制條件 ——因此我們能
將注意力集中在事關重要的變數。因此，許多正常狀態空間搜尋無法處理的問題，在予以公式化成 
CSP後，能夠被迅速地解出。 

6.1.2範例問題：加工車間排程 
有整天作業排程問題的工廠，承受了各式的限制。實際上，許多這些問題都已透過 CSP 技術被
解出。考慮一輛車子的組裝排程問題。整個作業是由數個任務所組成，而我們能夠將每個任務塑造
如同一個變數，其中每個變數的值是任務開始的時間，以分鐘數來表示。限制條件能夠要求說某個
任務必須在另一個任務之前出現 ——舉例來說，一個車輪必須先於輪轂罩裝上之前安裝好 ——且只
有如此許多的任務才能夠同時開展。限制也能夠指明某個任務需耗時多久才能完成。

我們考慮一小部份的車輛組裝任務，共有 15個任務：安裝車軸(前面和後面)，裝上所有四個輪
子(左/右/前/後)，擰緊每個車輪的螺母，裝上轂蓋，最後組裝檢查。我們能夠以 15個變數來表示這
些任務： 

X = {AxleF, AxleB, WheelRF, WheelLF, WheelRB, WheelLB, NutsRF, 
NutsLF, NutsRB, NutsLB, CapRF, CapLF, CapRB, CapLB, Inspect}


每個變數的值是任務開始的時間。接著我們表示出各個任務間的前提限制。每當一個任務 T1必須在
任務 T2之前出現，而任務 T1需耗用時間 d1來完成，我們加入一個如下形式的數學性限制 

T1 + d1 . 
T2

在我們的例子中，在安裝輪子之前，輪軸必須先到位，放置車軸需要 10分鐘，所以我們寫成 

AxleF + 10 . 
WheelRF；AxleF + 10 . 
WheelLF； 
AxleB + 10 . 
WheelRB；AxleB + 10 . 
WheelLB


然後我們說，對每個輪子，我們必須使輪子固定好(需時 1分鐘)，然後擰緊螺母(2分鐘)，最後附上
的輪轂罩(1分鐘，但是還沒有被表示出來)： 
WheelRF +1 . 
NutsRF；NutsRF +2 . 
CapRF； 
WheelLF +1 . 
NutsLF；NutsLF +2 . 
CapLF； 
WheelRB +1 . 
NutsRB；NutsRB +2 . 
CapRB； 
WheelLB +1 . 
NutsLB；NutsLB +2 . 
CapLB

假設我們有四個工人安裝輪子，但是它們必須共用一個能協助輪軸定位的工具。我們需要一個選言
限制(disjunction constraint)來說明 AxleF與 AxleB在時間上必須不能重疊；不是其中一個先做，就是另
一個先做：


.6-4..6-4.
人工智慧 
–現代方法 
3/E 


(AxleF + 10 . 
AxleB )或 
(AxleB + 10 . 
AxleF )

這看起來像是一個更複雜的限制，結合了數學與邏輯。但是它仍然被簡化成 
AxleF與 
AxleF能適用之
成對值的集合。

我們也必須聲明檢查工作會最後完成並需時 
3分鐘。除了 
Inspect，對每一個變數我們加了這個
形式 
X + dX . 
Inspect的限制。最後，假設有一個需求是整個組裝必須在 
30分鐘內完成。我們能夠藉
由限制所有變數的值域來達成： 


Di = {1, 2, 3,..., 27}

這個特別的問題很容易解出，但是已經被應用於如此類的加工車間排程問題的 
CSP多具有上千個變
數。於某些情況，有些複雜的限制很難以 
CSP 形式化的方法來具體說明，此時會援用更高層次的規
劃技術，如第 
11章所述。 


6.1.3 CSP形式化的變種
最簡單的一種 
CSP其涉及的變數具有離散且有限的值域。地圖著色的問題以及有時間限制的排
程這兩者都屬於這一種。第三章中描述的八皇后問題也可以視為有限值域的 
CSP，其中變數 
Q1, …,Q8
是每個皇后在列 
1, …, 8中的位置，每個變數的值域是{1, 2, 3, 4, 5, 6, 7, 8}。

一個離散值域可能是無限的，如整數或是字串的集合 
(如果我們不對作業排程問題加上截止期
限，那麼每個變數的開始時間就會有無限多個 
)。用無限值域，不再可能透過列舉所有可能取值的組
合來描述限制條件了。取而代之的做法是，必須借用限制語言來了解限制如 
T1 + d1 . 
T2，不用一一
列出可允許之(T1, T2)值對的集合。對於整數變數的線性限制——也就是，諸如剛剛給出的限制，其
中每個變數都只以線性形式出現——存在特殊的求解演算法(我們在這裡不討論)。可以證明沒有演算
法能夠求解一般的整數變數的非線性限制問題。

連續值域的限制滿足問題在現實世界是十分常見的，並在作業研究值域中有廣受研究。例如在
哈伯太空望遠鏡上的實驗排程安排要求非常精確的觀測時間選擇；每次觀測的開始、結束時間和機
動時間都是連續值變數，它們必須遵守許多天文的、優先權的和電力的限制。最著名的連續值域 
CSP
是線性規劃問題，其中限制必須是構成一個凸多邊形的一組線性不等式。線性規劃問題可以在與變
數數有關的多項式時間內求解。有不同類型的限制和目標函數的問題也已廣為研究 
——二次規劃，
二階二次曲線規劃，等等。

除了考察出現在 
CSP問題中的變數的種類，考察限制的類型也是有用的。最簡單的類型是一元
限制，它只限制單個變數的取值。舉例來說，於地圖著色問題可能會有南方澳洲人不會容忍綠色的
情況；我們能將之表示為一元限制.(SA), SA ≠ green.。

一個二元限制與兩個變數有關。例如， 
SA ≠ 
NSW就是一個二元限制。二元 
CSP只包含二元限制；
它可以表示為限制圖，如圖 
6.1(b)。

我們也能描述更高層次的限制，如聲明 
Y的值介於 
X與 
Z之間，具有三元限制 
Between(X, Y, Z)。


Ch6限制滿足問題 


.6-5. 
一個可以有任意個變數數目的限制被稱之為一個全局限制(這名稱很傳統但是容易混淆因為它
不要求於一個問題中用到所有的變數)。最常見的全局限制之一是 
Alldiff，說的是與限制有關的變數
必須有不同的值。於數獨 
(Sudoku)問題(見第 
6.2.6節)，於一行或列的所有變數必須滿足 
Alldiff限制。
另一個例子是密碼算術遊戲 (參見圖 
6.2b)。於一個密碼算術遊戲的各個字母代表不同的數字。在圖 


6.2(a)所示的情況下，這將表示為一個六變數限制 
Alldiff (F, T, U, W, R, O)。遊戲中四欄的加法限制可
以寫成如下數的 
n元限制： 
O + O = R + 10•C10 
C10 + W + W = U + 10•C100 
C100 + T + T = O + 10•C1000 


C1000 = F
其中 
C10、C100、C1000是代表十位數，百位數，或千位數之數字的輔助變數。高階限制可以用限制超
圖表示，諸如圖 
6.2(b)所示。超圖是由一般的節點(圖中的圓圈)與超節點(方格)組成，它代表表 
n元
限制。 


C C C
圖 6.2 (a) 一個密碼算術遊戲。每個字母表示一個不同的數字；目標是找到能使加法式子成立的代替字
母的數字，附加限制是最前面的數字不能是 0。(b)密碼算術問題限制超圖，顯示 Alldiff限制(頂端的方格 )，
以及欄的加法限制 (中間的四個方格 )。變數 C1、C2、C3代表三個欄的進位數字。

另一方面，如習題 
6.5所要求你證明者，如果引進了足夠的輔助變數，每個有限值域的限制可
以被簡化為一個二元限制的集合，所以我們可以轉換任何 
CSP為一個僅具有二元限制的問題；這使
得這個演算法更簡單。另一個轉換 
n元 
CSP為一個二元問題的方法是雙圖形轉換(dual graph 
transformation)：製作一張新的圖，於這張圖中，為原圖中的每個限制提供一個變數，並且對於共享
變數之原圖中的每對限制提供一個二元限制。舉例來說，如果原圖中有個變數 
{X, Y, Z}與限制.(X, Y, 

Z), C1.與.(X, Y)，C2.那麼雙圖形會有變數{C1, C2}且具有個二元限制.(X, Y), R1.，其中(X, Y)是共享變
數且 
R1是一個的新關係，它定義了共享變數之間的限制，由原來的 
C1與 
C2所指明。
不過有兩個原因為什麼我們偏好全局限制如 
Alldiff而非二元限制的集合。第一，使用 
Alldiff來
描述問題會更容易且不容易出錯。第二，針對無法用於更原始限制集合之全局限制來設計專用的推
論演算法有是可能的。我們於第 
6.2.5節描述這些推論演算法。


.6-6..6-6.
人工智慧 
–現代方法 
3/E

到目前為止我們已經描述過的限制都是絕對限制，任何違反規則的都排除在解之外。然而許多
現實世界的 
CSP包含偏好限制，指出哪些解是更偏好的。舉例來說，在大學課程排程的問題上有個
絕對限制是沒有任何教授能同一時間教授兩門課程。但是我們也可以允許偏好限制 
(preference 
constraints)：R教授可能比較喜歡在早上授課，然而 
N教授比較喜歡在下午授課。X教授在下午 
2
點授課的時間表雖然是一個解 
(除非 
X教授正好是系主任)，但不是最佳解。偏好限制通常被計入個
體變數賦值的成本——例如，分配給 
X教授下午時段在總體目標函數中需要消耗 
2點，而上午時段
只需要消耗 
1點。用這種形式化，有偏好限制的 
CSP問題可以用基於路徑的或局部的最佳搜尋方法
求解。我們稱這樣的問題是限制最佳化問題，或 
COP。線性規劃問題做這種最佳化。 


限制的傳播：於 CSP推理

於正常的狀態空間搜尋，一個演算法只能做一件事情：搜尋。於 
CSP有一個選擇：演算法能搜
尋(從數個可能性選取一個新的變數賦值)或是做一個特定類型稱之為限制傳播(constraint propagation)
的推理：使用限制以降低某個變數合法值之數目，從而降低另一個變數的合法值之數目等等。限制
的傳播可能與搜尋緊密相連，或在搜尋開始之前，它可以被當做一個預先處理步驟 
,。有時候這樣的
預先處理能解出全部問題，所以根本不需要搜尋。

關鍵的概念是局部相容性。我們對待每個變數如同圖中的一個節點 
(見圖 
6.1b)以及每個二元限制
如同一個邊，那麼強化圖形各部份之局部相容性的過程所造成的不相容值會在整張圖中被消除。局
部相容性有不同的類型，我們將逐一介紹。 


6.2.1節點相容性 
一個單一個變數(相應於 
CSP網路的節點)屬於節點相容(node-consistent)，如果於該變數的值域
中所有的值都滿足該變數的一元限制。舉例來說，在澳洲地圖著色問題的變種題目(圖 
6.1)其中南澳
人不喜歡綠色，變數 
SA以值域{red, green, blue}開始，我們可以藉由消去綠色使之為節點相容，留
下的是縮減了的值域{red, blue}的 
SA。我們說一個網路是節點相容的，如果於該網路中的每一個變
數是節點相容的。

藉由執行節點相容性來消去一個 
CSP中的限制總是可能的。轉換所有的 
n元限制為二元限制也
是可能的(見習題 
6.5)。因為這樣的原因，定義僅能運用於二元限制的 
CSP求解器就變得很常見；我
們在本章其後的內容都做如此的假設，除了特別註明之外。 


6.2.2邊相容性 
於一個 
CSP的一個變數是邊相容(arc-consistent)，如果變數的值域中的每一個值都滿足變數的二
元限制。更正式地說， 
Xi對另一個變數 
Xj是邊相容的，如果於目前的值域 
Di中的每一個值，於值域 
Dj有一些值滿足加諸於邊(Xi, Xj)的二元限制。一個網路屬於邊相容性，如果每一個變數與其他的變
數都是邊相容的。舉例來說，考慮限制 
Y = X2其中 
X與 
Y值域是數字的集合。我們能夠直接地寫出
這個限制為


Ch6限制滿足問題 


.6-7. 
.(X, Y), {(0, 0), (1, 1), (2, 4), (3, 9))}.

要使得 
X對 
Y是邊相容的，我們縮減 
X的值域成{0, 1, 2, 3}。如果我們也是讓 
Y對 
X是邊相容的，
那麼 
Y的值域變成{0, 1, 4, 9}且整個 
CSP是邊相容的。

另一方面，邊相容性為澳洲地圖著色問題幫不上忙。考慮下述加諸於(SA, WA)的不等式限制： 


{(red, green), (red, blue), (green, red), (green, blue), (blue, red), (blue, green)}

不論你為 
SA(或是 
WA)選取哪一個值，對其他的變數總有一個真確的值。所以施加邊相容性並不會
影響任一個變數的值域。

最流行的邊相容性演算法已知是 
AC-3(見圖 
6.3)。要使每一個變數為邊相容的，AC-3演算法保
留一個邊的佇列供作考慮之用。 
(實際上，考慮的前後順序並不重要，所以在資料結構實際上是一個
集合，但是習慣稱它是一個佇列)。剛開始時，該佇列儲存了 
CSP中所有的邊。AC-3然後從佇列中
隨意地挑出一個邊(Xi, Xj)並且讓 
Xi對 
Xj為邊相容的。如果這讓 
Di沒什麼改變，該演算法就移到下一
個邊。但是如果更動了 
Di (使得該值域縮小些)，那麼我們將所有 
(Xk, Xi)邊加進佇列之中，其中 
Xk是
一個 
Xi的鄰居。我們必須如此做，因為 
Di的改變可能會讓 
Dk的值域進一步減縮，即使我們前面已
經考慮過 
Xk了。如果 
Di被修改得一無所有，那麼我們知道整個 
CSP沒有相容的解答，而 
AC-3會立
即地傳回失敗。否則，我們一直檢查，嘗試把數值從變數的值域移出，直到佇列中沒有任何邊。在
那個時候，我們手上有個等價於原始 
CSP的 
CSP——它們兩個都有相同的解——但是在大多數情況
下邊相容的 
CSP的搜尋會快速些，因為它的變數有更小的值域。


圖 6.3邊相容演算法 AC-3。在使用 AC-3之後，每一個邊是邊相容的，或是某些變數有個空的值域，顯
示出該 CSP無法被解出。該演算法的發明者 (Mackworth，1977)使用「 AC-3」這個名字，是因為這是他論
文中的第三個版本


.6-8..6-8.
人工智慧 
–現代方法 
3/E 


AC-3的複雜度可以分析如下：假設一個有 
n個變數的 
CSP，每個值域的大小最多是 
d，且具有 
c個二元限制(邊)。每個邊 
(Xk, Xi)可以被插入佇列最多 
d次，因為 
Xi最多有 
d個值可以刪除。檢查一
個邊的相容性可以在 
O(d2)量級的時間內完成，所以我們得到最壞情況總時間是 
O(cd3)[1]。

延伸邊相容性的符號來處理 
n元而非只是二元限制是可能的；這稱之為一般化邊相容性或有時
候稱之為超邊相容性，視作者而定。稱一個變數 
Xi對一個 
n元限制是一般邊相容，如果於 
Xi的值域
中的每一個值 
v，存在一個隸屬於該限制之成員的元組值，它的值全取自相應之變數的值域，並且讓
它的 
Xi的分量等於 
v。舉例來說，如果所有的變數擁有值域 
{0, 1, 2, 3}，那麼要使變數 
X與限制 
X < Y 
< Z相容，我們必須從 
X的值域除去 
2和 
3，因為當 
X等於 
2或 
3的時候，該限制是無法被滿足的。 


6.2.3路徑相容 
邊相容性在朝向縮減變數的值域時，可能會走很長的路，有時候找到解答 
(藉由縮減每個值域的
大小達到 
1)而有時候發現 
CSP無法被解出(每個值域的大小縮減為 
0)。但是對於其他網路，邊相容
性無法製造足夠的推理。考慮澳洲地圖著色問題，不過只允許使用兩種顏色，紅色和藍色。邊相容
性什麼也不用做，因為每一個變數已經是邊相容的：每個邊可能一端是紅而另一端是藍的 
(或者反過
來也行)。但是很清楚地該問題沒有解答：因為西澳大利亞州，北領地和南澳都彼此接壤，就這三個
區域我們就至少需要三種顏色。

邊相容性使用邊(二元限制)收緊值域(一元限制)。要想在地圖著色的問題上有所進展，我們需要
更強的相容概念。路徑相容藉由檢視三倍的變數所推論出的間接性限制來收緊二元限制。

一個雙變數集合{Xi, Xj}對第三個變數 
Xm是路徑相容的，如果對每一個賦值{Xi = a, Xj = b}與加
諸於{Xi, Xj}之限制，有一個賦值 
Xm滿足加諸於{Xi, Xm}與{Xm, Xj}之限制。這稱之為路徑相容，因為
你可以想像成正望著一條從 
Xi到 
Xj的路徑而 
Xm位在路中間。

讓我們看看路徑相容如何用兩種顏色塗澳洲地圖。我們會使得集合{WA, SA}路徑相容於 
NT。
我們列舉對集合相容之賦值開始。這樣的話，僅有兩個：{WA = red, SA = blue}與{WA = blue, SA = 
red}。我們可以看到 
NT的這兩個賦值既不能是紅色的也不能是藍色的(它會與 
WA或 
SA的顏色發生
衝突)。因為沒有適用於 
NT的選擇，我們除去這兩個賦值，而我們得到的結果是沒有合適的值可賦
予{WA, SA}。因此，我們知道對這問題不可能有答案。 
PC-2演算法(Mackworth，1977)達成路徑相容
的方式與 
AC-3達成邊相容的方式非常相似。因為它是如此的相似，我們在這裡就不多做說明。 


6.2.4 K-相容
用 
k相容的概念可以定義更強的傳播形式。如果對於任何 
k-1個變數的相容賦值，第 
k個變數
總能被賦予一個和前 
k-1個變數相容的值，那麼這個 
CSP問題就是 
k相容的。1-相容說的是，已知
空集合，我們可以讓任何一個變數的集合是相容的：這我們稱之為節點相容。 
2相容和邊相容是一
樣的。對於二元限制網路，3-相容與路徑相容是相同的。


Ch6限制滿足問題 


.6-9. 
如果一個圖是 
k相容的，也是 
k-1相容的、 
k-2相容的、 
…，直到 
1相容，那麼這個圖是強 
k相
容的。現在假設我們的 
CSP問題有 
n個節點而且令它是強 
n相容的(即 
k = n時的強 
k相容)。我們然
後能求解該問題如下：首先，我們對變數 
X1選擇一個相容值。我們保證能夠給 
X2也選擇一個相容
值，因為它是 
2相容的，對 
X3也如此，因為它是 
3相容的，等等。對每個變數 
Xi，我們只需要在值
域內的 
d個值中找到與 
X1, …, Xi－1相容的值。我們被保證在 
O(n2d)時間內找到解。當然，世上沒有
免費的午餐：任何建立 
n相容的演算法在最壞情況下必須花費 
n的指數時間。更糟的是，n-相容也
需要 
n的指數量級的空間。記憶體的問題比時間的問題更嚴重。實際上，決定合適的相容性檢驗層
次的主要是經驗科學。可以說使用者通常會用 
2相容來計算而比較少用 
3相容。 


6.2.5全局限制 
請記得全局限制說的是一個擁有任意數目之變數(但不必然是所有變數)的限制。全局限制經常出
現在實際問題中，且用專用演算法處理的效率比用至今描述的通用方法要更高。例如， 
Alldiff限制
要求涉及的全部變數都必須取不同的值(如密碼算術問題)。Alldiff限制問題的矛盾檢測的一個簡單形
式包括如下工作：如果限制中涉及 
m個變數，且它們一共有 
n個可能的不同取值，並且 
m > n，則
這個限制不可能被滿足。

這引出了下面的簡單演算法：首先，刪除限制中只有單值值域的變數，然後將這些變數的取值
從其餘變數的值域中刪去。只要還有單值變數，就重複這個過程。如果得到一個空的值域或者剩下
的變數數比剩下的數值個數大，那麼就產生矛盾。

這個方法可檢測圖 
6.1中的賦值{WA = red, NSW = red}的矛盾。注意變數 
SA，NT和 
Q是透過 
Alldiff限制有效連接起來的，因為它們之間任何兩個都要著不同的顏色。在這個不完全賦值上應用 
AC-3演算法，每個變數的值域就縮小為 
{green, blue}。就是說我們有三個變數但只有兩種顏色可選，
所以違反了 
Alldiff限制。因此一個高階限制的簡單相容過程有時候比把邊相容用於二元限制的等價
集合效率更高。也有更為複雜而能傳播更多限制但是執行上計算更昂貴的推理演算法可用於 
Alldiff 
(見 
van Hoeve及 
Katriel，2006)。

另一個重要的高階限制是資源限制，有時稱為大多數(atmost)限制。例如，在排程問題中，
令 
P1, …, P4表示分配給四項任務的人員個數。總共分配不超過 
10人的限制記為 
atmost(10, P1, P2, P3, P4)。透過檢驗當前值域中的最小值之和就能檢測出矛盾；例如，如果每個變數
的值域為{3, 4, 5, 6}，就不能滿足 
atmost的限制。我們也可以透過刪除變數值域中與其他變數的值域
中的最小值不相容的最大值來保持相容性。因此，在我們的例子中如果每個變數的值域是 
{2, 3, 4, 5, 
6}，那麼 
5和 
6可以從每個變數的值域中刪去。

對於大型的整數值的資源限制問題 
——諸如涉及用數以百輛計交通工具來運送數以千人這樣的
後勤問題——用整數集合來表示每個變數的值域，然後透過相容性檢驗方法逐步削減集合，通常是
不可能的。換個方式，值域用上界和下界來表示，並透過邊界傳播來管理。例如，在一個航線排班
問題中，假設有兩次航班 
F1和 
F2，分別有 
165和 
385個座位。每次航班可承載的乘客數的初始值域
為


.6-10..6-10.
人工智慧 
–現代方法 
3/E 


D1 = [0, 165]及 
D2 = [0, 385]
現在假設我們又有一個附加限制，這兩次航班所載的總乘客數必須是 
420：F1 + F2 = 420。傳播邊界
限制，我們可以把值域縮減成 
D1 = [35, 165]及 
D2 = [255, 385]
如果對於每個變數 
X和它的取值的上下界，每個變數 
Y都存在某個取值滿足 
X和 
Y之間的限制，我
們稱該 
CSP問題是邊界相容的。這種邊界傳播廣泛應用於實際的限制問題。 


6.2.6數獨例子 
圖 6.4 (a) 一個數獨謎題； (b) 它的解答
限制滿足問題已透過受歡迎的數獨謎題引介給數百萬人了，儘管他們或許並不自知。數獨板是
由 
81個方格所組成，其中某些方格剛開始時已經填入了 
1到 
9等數字。謎題是在剩下的方格中填入
數字使得沒有任何數字會在同一行、同一欄，或是一個 
3×3的方框範圍內出現兩次(見圖 
6.4)。一行，
一欄，或是方框稱之為一個單位。
印在報紙與謎題書的數獨謎題有恰好有一解的特性。儘管有些謎題以手算的方式來求解會很棘
手，可能耗時達十數分鐘，但即使最難的數獨問題 
CSP求解器也能在不到 
0.1秒的時間內解出。
一個數獨謎題被視為一個具有 
81個變數的 
CSP，每個格子是一個變數。最上一行(從左至右)我
們使用變數名稱 
A1至 
A9，直到最後一行使用 
I1至 
I9。空的格子有值域 
{1, 2, 3, 4, 5, 6, 7, 8, 9}而預
先填好數字的格子單一值所組成的值域。除此之外，有 
27不同的 
Alldiff限制：一個針對每個行，欄，
與 
9格框。 
Alldiff 
(A1, A2, A3, A4, A5, A6, A7, A8, A9) 
Alldiff 
(B1, B2, B3, B4, B5, B6, B7, B8, B9) 
… 


Ch6限制滿足問題 


.6-11. 
Alldiff 
(A1, B1, C1, D1, E1, F 1, G1, H1, I1) 

Alldiff 
(A2, B2, C2, D2, E2, F 2, G2, H2, I2) 

… 

Alldiff 
(A1, A2, A3, B1, B2, B3, C1, C2, C3) 

Alldiff 
(A4, A5, A6, B4, B5, B6, C4, C5, C6)
讓我們看看邊相容性能夠如何引領我們。假設 
Alldiff限制已經被擴增為二元限制(如 
A1 ≠ 
A2)使得我
們能直接運用 
AC-3演算法。考慮圖 
6.4(a)的變數 
E6——在中間框中介於 
2與 
8之間的空格。從方框
的限制條件，我們不僅僅能夠從 
E6值域移除 
2與 
8也包括 
1與 
7。從它的欄限制，我們能消除 
5, 6, 
2, 8, 9, 3。這讓 
E6留下值域{4}；換言之，我們知道 
E6的答案。現在考慮變數 
I6——那個被方框 
1, 
3及 
3圍繞的底部中間的框的方格。運用邊相容性於該欄，我們消去了 
5, 6, 2, 4(因為我們現在知道 
E6必須是 
4), 8, 9與 
3。藉由 
I5的邊相容性我們除去 
1，於值域 
I6我們僅剩下值 
7。現在於欄 
6有 
8
個已知值，所以邊相容性能夠推論出 
A6必須是 
1。沿著這些線索持續推理，最後，AC-3能求解整
個謎題——所有的變數將它們的值域縮減為單一值，如圖 
6.4(b)所顯示者。

當然，如果每一個謎題能夠以機械性的運用 
AC-3來解出數獨的話，它很快就會失去吸引力，
確實 
AC-3僅僅能對最簡單的數獨謎題發揮效用。略微難的謎題能夠被 
PC-2解出，但是在一個更高
昂的計算成本之下：考慮一個有 
255,960不同的路徑限制的數獨謎題。想要解出最難的謎題並且讓
解題進展有效率，我們需要更聰明些。

確實，數獨謎題對於人類求解器的吸引力在於運用更複雜的推理策略時必須是資源充足的。數
獨迷給了它們富有色彩的名字，如「三聯顯數格」 
(naked triples)該策略作用的方式如下：在任何單
元中(行，欄或框 
)，找出三個格子，這些格子中都有一個包含相同的三個數字或是一個那些數字之子
集合的值域。舉例來說，三個值域也許是 
{1, 8}，{3, 8}與{1, 3, 8}。從那兒我們不知道哪一個格子中
包含 
1，3，或 
8，但是我們真的知道那三個數字必然在那三個格子中。因此我們能夠自該單元中每
隔一個格子之值域中拿走 
1，3與 
8。

令人感興趣的是注意到我們能走多遠而不用說那是特別針對數獨而為者。我們當然必須說有 
81
個變數，它們的值域是數字 
1至 
9，且有 
27個 
Alldiff限制。除此之外，所有的策略 
——邊相容，路
徑相容等等——將一般性地運用至所有的 
CSP，而非只是數獨問題。即使三聯顯數格其實是個用於
強化 
Alldiff限制之相容性的策略，本來就與數獨無關。這是 
CSP正規型式的威力所在︰對於每個新
問題值域，我們僅須以限制來定義問題；然後一般的限制求解機制就可以接手處理。 


CSP問題的回溯搜尋

數獨問題設計上是用來於限制下做推理來解題。但是許多其他 
CSP無法單單由推理來解出；總
會有這麼個時候我們必須搜尋一個解答。在這一節我們看看回溯搜尋演算法如何運用於不完全賦
值；在下一節我們看看局部搜尋演算法如何蘊運用於完全賦值。


.6-12..6-12.
人工智慧 
–現代方法 
3/E

我們能夠運用標準的深度限制搜尋(第 
3章)。狀態會是不完全賦值，且於賦值中某個動作會加進
一個 
var = value。但是對於一個具有 
n個值域大小為 
d之變數的 
CSP，我們很快地注意到一件可怕
的事情：頂層的分支參數就是 
nd，因為 
d個值的任何一個都可以賦給 
n個變數的任何一個。在下一
層，分支參數是 
(n –1)d，依此類推 
n層。我們產生了一棵有 
n!•dn個葉子的搜尋樹，儘管只有 
dn個
可能的完全賦值！

我們表面上似乎很合理但是天真的形式，忽略了常見於所有的 
CSP的關鍵特性：可交換性。如
果任何給定行動集的施用順序對結果沒有影響，那麼這個問題就是可交換的。CSP是可交換的，因
為對變數作賦值的時候，不論賦值順序為何，我們都會到達相同的不完全賦值。因此，於每個搜尋
樹的節點我們僅須考慮一個變數。例如，在對澳大利亞地圖進行著色的搜尋樹的根節點，我們可能
要在 
SA = red，SA = green和 
SA = blue之間選擇，但我們永遠不會在 
SA = red和 
WA = blue之間做選
擇。有了這個限制，葉節點的個數如我們所希望的減少到了 
dn個。

回溯搜尋可用於深度優先搜尋，一次為一個變數選擇值，當沒有合法的值可以再賦給該變數時
就回溯。該演算法如圖 
6.5。它重複地選擇一個尚未被賦予值的變數，然後依次嘗試那個變數之值域
中的所有值，試圖找出一個解答。如果發覺有不相容的情事，那麼 
BACKTRACK傳回失敗的訊息，
使得前一個程式呼叫去試另一個值。圖 
6.6顯示了澳大利亞問題的部分搜尋樹，其中我們按照 
WA， 
NT，Q，……的順序來給變數賦值。因為 
CSP問題的表示是標準化的，不需要給 
BACKTRACKING搜
尋提供特定值域的初始狀態、後繼函數或目標測試。


圖 6.5限制滿足問題的一個簡單回溯演算法。該演算法以第三章的遞迴深度優先搜尋為模型。將函數 
SELECT-UNASSIGNED-VARIABLE和 ORDER-DOMAIN-VALUES作變化，我們可實作課文中討論的通
用啟發式演算法。函數 INFERENCE可視需要而選擇性加上邊 -、路徑 -、或 k-相容性。如果所選擇的值造
成失敗(由 INFERENCE或 BACKTRACK所通知)，則賦值 (包括由 INFERENCE所做的)會從目前的賦值
中被移除，而且會嘗試一個新的值


Ch6限制滿足問題 


.6-13. 
圖 6.6
圖 6.1中的地圖著色
問題的部分搜尋樹


請留意 
BACKTRACKING-搜尋只保留一個狀態的單一表示並改變該表示而非創造新的一個，如 


3.4.3所述。
在第 
3章中，我們透過提供源自問題知識的值域特定的啟發函數，來彌補無接收資訊的搜尋演
算法的不佳性能。結果顯示，我們可以不用特定值域的知識就有效地解決 
CSP問題。相反的，我們
能增加一些複雜度到圖 
6.5中未指定的函數，使用它們來凸顯下述問題： 


1.下一步該對哪個變數作賦值(SELECT-UNASSIGNED-VARIABLE)，又要按什麼順序來嘗試它的
值(ORDER-DOMAIN-VALUES )？ 
2.於(INFERENCE)搜尋中每一個步驟該執行什麼樣的推理？ 
3.當搜尋抵達某一個違反限制的賦值，該搜尋是否能避免重蹈失敗的覆轍？
接下來的的幾個小節將逐一回答這些問題。 


6.3.1變數和賦值順序
回溯演算法有這麼一行： 


var ← SELECT-UNASSIGNED-VARIABLE(csp) 

SELECT-UNASSIGNED-VARIABLE用的最簡單的策略是依照順序選取下一個還沒賦予值的變數， 
{X1, X2, …}。這種靜態的變數排序很少能造成高效率的搜尋。例如，在賦值 
WA = red和 
NT = green
之後， 
SA只剩下一個可能的賦值，因此下一個賦值 
SA = blue要比給 
Q賦值有意義。實際上，在給 
SA賦值之後， 
Q，NSW和 
V的選擇都是強制性的了。這種直觀的想法 
——選擇「合法」取值最少
的變數——稱為最少剩餘值(MRV)啟發式演算法。也稱為「最受限制變數」或「失敗優先」啟發
式演算法，後者的叫法是因為它選擇了最可能很快導致失敗的變數，從而對搜尋樹剪枝。如果某些
變數 
X沒有合法的值可供選用，MRV啟發式會選擇 
X並立刻偵知失敗了——避免了無頭蒼蠅似的
搜尋其他變數。 
MRV啟發式通常執行的效能較隨機或靜態排序來的好，有時候達到 
1,000或更高的
倍數，儘管其結果會視問題之不同而有甚大的差距。 


MRV啟發式演算法在澳大利亞問題中對選擇第一個著色區域根本沒有幫助，因為初始的時候每
個區域都有三種合法的顏色。在這種情況下，鄰接度啟發式(degree heuristic)演算法便顯得很好用。
它試圖藉由選擇牽涉到其他尚未賦值變數之限制數目為最大的變數來降低未來選擇的分支因數。在
圖 
6.1中，SA是有最高的鄰接度的變數，它的鄰接度為 
5；其他變數的鄰接度為 
2或者 
3，除了 
T


.6-14..6-14.
人工智慧 
–現代方法 
3/E

的鄰接度為 
0。實際上，一旦選擇了 
SA，應用鄰接度啟發式演算法求解問題可以不走錯任何一步 
——
你可以在每個選擇點上選擇任何相容的顏色，仍然可以不回溯就找到解。最少剩餘值啟發式演算法
通常是一個更強的指導，而鄰接度啟發式演算法則對打破僵局有用。

一旦一個變數被選定，演算法就要決定檢驗它的取值的次序。為此，最少限制值啟發式演算法
在某些情況下是有效率的。在限制圖中排除鄰居變數之可選取值為最少的值會被優先選擇。例如，
假設在圖 
6.1中，我們已經製作出不完全賦值， 
WA = red和 
NT = green，我們下一步要為 
Q選擇值。
這裡藍色不是一個好的選擇，因為它消除了 
Q的鄰居 
SA的最後一個可選用的合法值。最少限制值
啟發式演算法因此更願意選擇紅色而不是藍色。一般來說，啟發式演算法應該試圖給剩下的變數賦
值留下最大的靈活性。當然，如果我們試圖找到某個問題的所有解，而不只是第一個解，那麼這個
排序就無所謂了，因為無論如何我們要考慮每個值。當問題沒有解的時候也是一樣。

為什麼變數的選取方式該是失敗優先，而值的選取方式卻是失敗墊後？原來，對各式各樣的問
題，一個選取剩餘值個數最少之變數的變數順序有助於早些修剪大部份的搜尋樹來最小化搜尋樹之
節點數目。對於值的順序，技巧在於是我們只需要一個解答；因此先尋找最可能的值是合理的做法。
如果我們想要列舉出所有的解答而非只是找出一個，那麼值的順序就無關緊要了。 


6.3.2交錯搜尋與推理 
到目前為止我們已經看到 
AC-3 與其他演算法如何在我們開始搜尋之前先推理來縮減變數的值
域。但是在搜尋期間做推理甚至可能更具威力：每當我們為該變數選擇一個值，我們就有一個在該
變數附近做推理新值域縮減的嶄新機會。

最簡單的推理形式被稱之為前向檢驗。無論何時只要變數 
X被賦予值了之後，前向檢查程序會
為之建立邊相容性：對於每個透過限制而連接到 
X的尚未賦值變數 
Y，從 
Y的值域刪除任何與為 
X
所選出之值不相容的值。因為前向檢驗僅僅做邊相容性推理，如果我們已經以預先處理的步驟完成
了邊相容性，那麼沒有理由做前向檢驗。。

圖 
6.7展示以前向檢驗做澳洲 
CSP問題的回溯搜尋。這個例子中需要注意兩個重點。第一，注
意在賦值 
WA = red和 
Q = green之後，NT和 
SA的值域都減小到了單個值；我們透過 
WA和 
Q傳播
的資訊刪除了這些變數上的一些分支。第二點需要注意的是，當賦值 
V = blue之後， 
SA的值域就變
成空的。因此，前向檢驗已經檢測到不完全賦值 
{WA = red, Q = green, V = blue}與問題的限制條件是
矛盾的，因此程式會立刻回溯。

如果我們結合 
MRV啟發式與前向檢驗，對許多的搜尋問題而言將會更有效率。考慮賦值 
{WA = 
red}後的圖 
6.7。直覺地，似乎那個賦值限制了它的鄰居，NT與 
SA，所以我們應該接著處理那些變
數，然後所有的其他的變數會各就其位。那正就是使用 
MRV所會發生的情況： 
NT和 
SA有兩個值，
所以兩者之一會被先選取，然後另一個，然後依序是 
Q，NSW和 
V。最後的 
T仍然有三個值，而且
任何它們三個中的一個都能發揮作用。實際上，我們可以把前向檢驗視為一個逐步增加地計算 
MRV
啟發式演算法完成任務所需資訊的高效方法。


Ch6限制滿足問題 


.6-15. 
雖然前向檢驗能檢驗出許多矛盾，它還是不能檢驗出所有的矛盾。問題是它使得目前變數是邊
相容的，但是不向前看而使得所有其他變數變得邊相容的。例如，考慮圖 
6.7中的第三行。它顯示
出當 
WA是 
red、Q是 
green的時候， 
NT和 
SA都被迫是 
blue。前向檢驗向前看得不夠遠而沒能注意
到這是個不相容：NT及 
SA為相鄰，所以不能有相同值。

該演算法稱之為 
MAC(Maintaining Arc Consistency)偵測到此不相容。當一個變數 
Xi被賦予一個
值，INFERENCE程序呼叫 
AC-3，但是與其將所有 
CSP的邊都放進一個佇列，我們僅從所有鄰近於 
Xj中尚未被賦予值的邊(Xj, Xi)開始。從那裡，AC-3以尋常的方式來做限制的傳播，而且如果有任何
變數的值域被縮減成空集合，對 
AC-3的呼叫就算失敗而我們立刻知道要回溯。我們能看得出 
MAC
較前向檢驗更有力，因為前向檢驗剛開始時對 
MAC佇列中的邊做的事與 
MAC所做者是相同的；但
是與 
MAC不同的是，當變數的值域出現變動時，前向檢驗並不遞迴地傳播限制。


圖 6.7使用前向檢驗方法的地圖著色搜尋的進行方式。首先賦值 WA = red；然後前向檢驗從其相鄰變數 
NT和 SA的值域中刪除 red。賦值 Q = green之後， green從 NT、SA、NSW的值域中被刪除。賦值 V = blue
之後，blue從 NSW和 SA的值域中被刪除，這時 SA已沒有合法值。 

6.3.3更聰明的回溯：向後看 
圖 
6.5中的 
BACKTRACKING-SEARCH演算法當某個分支上的搜尋失敗時，會採取一個簡單的
方針：倒退回前一個變數並且嘗試另一個值。這稱為時序回溯，因為重新存取的是時間最近的決策
點。在這個小節，我們考慮更好的可能性。

考慮我們在圖 
6.1的問題中按照固定的變數順序 
Q，NSW，V，T，SA，WA，NT，應用簡單回溯
演算法。假設我們已經產生了不完全賦值{Q = red，NSW = green，V = blue，T = red}。當我們嘗試
下一個變數 
SA時，我們發現任何值都無法滿足限制。我們倒退回 
T，試著賦予 
Tasmania新的顏色！
顯然這種做法很愚蠢——對 
T重著色不能解決 
South Australia的問題。

一個更聰明的回溯方法是回溯到一個或可修復此問題的變數 
——一個該讓 
SA可能值之一變為
不可能負起責任的變數。為做到這件事，我們將持續追蹤一組與某些 
SA值相互矛盾之值。集合(在 
{Q = red, NSW = green, V = blue,}的情況 
)，被稱之為 
SA之衝突集。後向跳躍方法回溯到衝突集中時
間最近的變數；在這種情況下，後向跳躍將跳過 
T而嘗試 
V的新值。這個方法很容易地經由修改 
BACKTRACK實作，使它在檢查一個合法值的同時累積衝突集。如果沒有找到合法值，那麼它利用
失敗標記返回衝突集中時間最近的變數。


.6-16..6-16.
人工智慧 
–現代方法 
3/E

眼尖的讀者會注意到前向檢驗演算法可以不需要額外的工作就能提供衝突集：當基於 
X的賦值
的前向檢驗從變數 
Y的值域中刪除一個值時，應該把 
X加入 
Y的衝突集裡。如果 
Y值域的最後一個
值被刪除，那麼 
Y衝突集中的賦值被加入 
X的衝突集。這樣，當我們到達 
Y的時候就知道如果回溯
應該回到哪個變數。

細心的讀者會注意到某些古怪之處：後向跳躍只出現在值域中的每個值都和當前的賦值有衝突
的情況下；但是前向檢驗能檢測到這個事件並且一旦到達這樣的節點就阻止搜尋！實際上，可以證
明每個被後向跳躍剪枝的分支在前向檢驗演算法中也被剪枝。因此，簡單的後向跳躍在前向檢驗搜
尋中，或者說在諸如 
MAC這樣使用更強的相容性檢驗的搜尋中是多餘的。

除了上一段文字中的觀察結果，隱藏在後向跳躍背後的想法仍然是值得稱許的：基於失敗的原
因而回溯。後向跳躍當一個變數的值域為空的時候會注意到失敗，但是在很多情況下，一個分支在
這發生很久以前就已經註定要失敗了。再次考慮不完全賦值{WA = red, NSW = red}(從我們前面的討
論中知道，它是矛盾的)。假設我們下一個嘗試 
T = red，然後給 
NT、Q、V、SA賦值。我們知道對
這最後四個變數沒有可以採行的賦值，因此最終我們用完了 
NT的所有可能取值。現在的問題是向
哪裡回溯？後向跳躍是行不通的，因為 
NT確實有和前面賦值的變數相容的值——NT沒有由前面能
導致失敗的變數所完整組成的衝突集。然而我們知道，NT，Q，V和 
SA這四個變數之所以會失敗，
是肇因於前面的一組變數，那些與這四個變數直接發生衝突的變數。這引出了關於諸如 
NT這樣一
個變數的衝突集的更深概念：是那組前面變數致使 
NT，連同任何其後的變數，沒有相容解。在這種
情況下，那組變數是 
WA和 
NSW，所以演算法會越過 
Tasmania回溯到 
NSW。按這種方式定義的衝
突集的後向跳躍演算法稱為衝突導向的後向跳躍。

我們現在必須解譯這些新的衝突集是怎樣計算的。實際上方法很簡單。一個搜尋分支的「終端」
失敗總是因為一個變數的值域變為空；該變數有一個標準的衝突集。在我們的例子中，SA失敗了，
它的衝突集(比如)是{WA, NT, Q}。我們後向跳躍到 
Q，而 
Q將 
SA的衝突集(當然減去 
Q本身)也就
是{NT, NSW}吸收到自己的直接衝突集裡；新的衝突集是 
{WA, NT, NSW}。就是說，在給定了前面對 
{WA, NT, NSW}的賦值之後，從 
Q向前是無解的。因此我們回溯到 
NT，集合中最近的一個。NT把 
{WA, NT, NSW}–{NT}吸收到自己的直接衝突集{WA}裡，得到 
{WA, NSW}(如上一段所說的)。現在演
算法如我們所希望的那樣後向跳躍到 
NSW。總結來說，令 
Xj是當前變數，再令 
conf (Xj)為其的衝突
集。如果 
Xj的每個可能取值都失敗了，後向跳躍到 
conf (Xj)中最近的一個變數 
Xi，並置 


conf (Xi) ← 
conf (Xi) ∪ 
conf (Xj ) .{Xi}

當我們面臨矛盾的情況，後向跳躍能告訴我們該回溯多遠，所以我們不用浪費時間去更改無助於修
復問題的變數。但是我們也希望避免再次地陷入相同的問題。當搜尋面臨衝突的境地時，我們知道
衝突集的某些子集合對該衝突是有責任的。限制學習是從造成問題之衝突集中尋找一個最小的變數
集合的構想。這個變數集合，加上它們的相應的值，被稱之為一個不良(no-good)。我們然後記錄下
不良，方式是在 
CSP中加入限制或是另外保留不良值的快取資料。


Ch6限制滿足問題 


.6-17. 
舉例來說，考慮於圖 
6.6底下一行的狀態 
{WA = red, NT = green, Q = blue}。前向檢查可以告訴
我們這個狀態是一個不良，因為沒有合法的值可賦予 
SA。在這個特別的情況，記錄不良並不能幫上
什麼忙，因為一旦我們從搜尋樹上剪斷這段分枝，我們將不會再次遇到這樣的組合。但是假設於圖 


6.6中的搜尋樹實際上是最先賦值予 
V與 
T的大型搜尋樹的一部份。那麼將 
{WA = red, NT = green, Q 
= blue}記錄為一個不良就變得值得了，因為對每個 
V與 
T可能賦值的集合我們會再一次的碰到同樣
的問題。
不良可以有效地被前向檢查或是後向跳躍所使用。限制學習是現今 
CSP求解器有效率解決複雜
問題的最重要的技術之一。 


CSP問題的局部搜尋

局部搜尋演算法(參見 
4.1節)對解許多 
CSP問題都很有效的。它們使用完整的狀態形式：初始
狀態給每個變數都賦予一個值，且搜尋會一次改變一個變數的取值。舉例來說，於八皇后問題 
(見圖 


4.3)，初始狀態可能是 
8皇后於 
8行的隨機配置，且每一步會移動一個皇后到它行內的一個新位置。
通常，剛開始的猜測會違反好幾個限制。區域搜尋的重點是如何剔除被違反的限制[2]。
在為變數選擇一個新值的時候，最明顯的啟發式演算法是選擇會造成與其他變數的衝突最小的
值——最小衝突(min-confilicits)啟發式演算法。圖 
6.8顯示了該演算法，而圖 
6.9圖示了這個演算法
應用於八皇后問題時的情況。

最小衝突在許多 CSP問題上的表現出乎意外地好。令人驚異的是，在 
n皇后問題上，如果你不
計算皇后的初始放置，最小衝突演算法的執行時間大體上獨立於問題的大小。它甚至能在平均 
50步
之內解決百萬皇后問題 
(在進行了初始賦值之後)。這個不尋常的現象激發了 
20世紀 
90年代對於局
部搜尋以及容易和難的問題之間的區別的大量研究(第 
7章)。粗略地說， 
n個皇后問題對於區域搜尋
來說是很容易的，因為解答稠密地分佈在狀態空間各處。最小衝突對於困難的問題也表現的不錯。
例如，它用於安排哈伯太空望遠鏡的觀察日程時間表，安排一周的觀察日程所花費的時間從三周 
(！)減少到了 
10分鐘。

所有第 
4.1節的區域搜尋技術都是應用於 
CSP的候選技術，且其中一些已經被證實非常有效。
於最小衝突啟發式下 
CSP的地貌通常有好幾個綿延起伏的高原。可能有數以百萬計的變數賦值其距
離解答之處只有一個衝突之遙。高原搜尋 
(Plateau search)——可以以相同的得分讓山肩移動到另一個
狀態——有助於區域搜尋找出一條脫離高原的路。在高原上的這般游走可以用禁忌搜尋(tabu search)
來引導：保留一份最近拜訪過之狀態的小型清單並禁止演算法回到那些狀態。模擬的退火 
(annealing)
方法也可以被用來脫離高原區。

另一個技術，稱之為限制加權 
(constraint weighting)，有助於集中心力於搜尋重要的限制。每個
限制給予一個限制加權，Wi，剛開始時都等於 
1。在每一個搜尋步驟，演算法選擇一對變數/值來更
改以便讓所有違反限制的總加權值為最低。然後藉著漸漸增加每個限制的權重來調整違反目前賦值
之限制的權值。這有兩個優點：它加入了高原的地形，以確保從目前狀態獲得改善是可能的，同時
它也隨著時間的推移，為那些經過證明很難解出的限制加些權值。


.6-18..6-18.
人工智慧 
–現代方法 
3/E

局部搜尋的另一個優勢是當問題改變時，它可以用於線上情況。這在排程問題中尤其重要。一
周的航班日程表可能涉及數以千次航班和數萬人次的分配，但是一個機場的惡劣天氣，可能就會打
亂原來的日程安排。我們希望以最小的更改來修改日程。這可以用從當前日程開始的局部搜尋演算
法很容易地完成。一個使用新限制集的回溯搜尋通常需要更多的時間，並且找到的解有可能要對當
前日程進行很多更改。


圖 6.8一個用局部搜尋解決 CSP問題的 MIN-CONFLICTS演算法。初始狀態的選擇可採隨機方式，或
藉由貪婪賦值過程依次為每個變數選擇一個最小衝突的值而完成。函數 CONFLICTS統計一個特定值破
壞限制的數量，在已知當前賦值的剩餘值的情況下


圖 6.9用最小衝突演算法解決八皇后問題的一個兩步解。每一步選擇一個皇后，在它所在列中重新分配
位置。衝突的個數 (在這個問題中是能攻擊到的皇后的個數 )在每個方格裡列出來。演算法將皇后移到最小
衝突的方格裡，最小衝突值有多個方格時則隨機地選取其中之一 

問題的結構 

在這一節中，我們考慮以什麼方式利用問題的結構，如限制圖所表示的，能快速地找到解。大
多數這裡所提的方法，除了 
CSP類型的問題之外，也適用於其他的問題，如機率性推理。畢竟我們
處理實際世界問題時，有希望的唯一辦法就是將它分解為很多子問題。再看一次澳洲地圖的限制圖 
(圖 
6.1b，重複於圖 
6.12a)，凸顯出一種事實： 
Tasmania和大陸不相連[3]。直觀上，顯然對 
Tasmania
著色和對大陸著色是獨立的子問題——任何對大陸區域著色的解和任何對 
Tasmania著色的解合併起
來，都得到整個地圖的一個解。獨立性可以簡單地透過在限制圖中尋找連通域來確定。每個連通域


Ch6限制滿足問題 


.6-19. 
對應於一個子問題 
CSPi。如果賦值 
Si是 
CSPi的一個解，那麼 
ii 是 
∪ 
CSPi的一個解。為什麼這是

∪ 
Si 
很重要的？考慮以下問題：假設每個 
CSPi有總共 
n個變數中的 
c個變數，c是一個常數。那麼就有 
n/c個子問題，解決每個子問題最多花費 
d c步工作，其中 
d為域的大小。因此總的工作量是 
O(d cn/c)，
是 
n的線性函數；而不進行分解的話，總的工作量是 
O(dn)，是 
n的指數函數。我們給一個更具體的
例子：將一個 
n = 80的布林 
CSP問題分解成 
4個 
c = 20的子問題，會使最壞情況下的時間複雜度，
從宇宙壽命那麼長的時間減少到一秒以內。

完全獨立的子問題很誘人，但是很少見。幸運地，某些其他圖形架構也很容易解出。舉例來說，
當任兩個變數僅僅由一條路徑所連通的時候，一個限制圖形是一棵樹。我們將證明任何一個樹狀結
構的 
CSP問題可以在變數個數的線性時間內求解[4]。關鍵之處是一個新的相容概念，稱之為有向的
邊相容性或 
DAC。一個 
CSP在變數順序 
X1, X2, …, Xn下被定義為是邊相容的，若且唯若各個 
Xi於 
j 
> i下與每一個 
Xj是邊相容的。

要求解一個樹狀架構的 
CSP，首先挑選任一個變數當做樹的根節點，並選取一個變數的順序使
得每個變數出現在樹的母節點之後。這樣的排序被稱之為拓樸排序。圖 
6.10(a)展示一棵範例樹，且 


(b)顯示一個可能的排序。任何具有 
n個節點的樹有 
n – 1個邊,因此我們能夠使得這個圖形於 
O(n)個
步驟內使之變為具有有向邊相容性，對於兩個變數而言每個步驟必須比較的可能的值域值多達 
d
個，總時間為 
O(nd2)。一旦我們有了有向邊相容的圖，我們只要逐一查看變數表並選取任何的剩餘
值。因為每個從母節點到子節點的連結是邊相容的，我們知道為任何我們選來當作母節點的值，將
會有一個正確值留用來選取為子節點。這意指我們不必須回溯；我們能線性地移動該變數。完整的
演算法如圖 
6.11所示。
現在我們已經有了一個對樹狀結構的高效演算法，我們可以考慮更一般的限制圖是否能簡化成
樹的形式。有兩種基本的方式：一種基於刪除節點，另一種基於合併節點。

第一種方法涉及先對其中的某些變數賦值，使剩下的變數能夠形成一棵樹。考慮澳大利亞的限
制圖，如圖 
6.12(a)所示。如果我們能刪除 
South Australia，這個圖就會變影像(b)中的一棵樹。幸運
的是，我們可以做到這個 
(只是在圖中刪除，而不是真的從大陸上刪除 
)，透過給變數 
SA固定的值並
且從其他變數的值域中刪除任何與為 
SA選中的值不相容的值。


圖 6.10 (a) 樹狀結構 CSP的限制圖。 (b)與以 A為根節點的樹相容的變數的線性排序。這稱為該變數的
拓樸排序


.6-20..6-20.
人工智慧 
–現代方法 
3/E


圖 6.11 TREE-CSP-SOLVER演算法用於求解樹狀架構 CSP。如果該 CSP有一個解答，我們會於線性時
間內找到它；如果沒有，我們會找出矛盾 


(a) (b)
圖 6.12 (a)圖 6.1的原始限制圖。 (b)刪除 SA之後的限制圖

現在，在刪除了 SA和它的限制之後， CSP問題的每個解都將與為 SA選擇的值是相容的。 (這對
二元 CSP問題是可行的；在高層次的限制問題中情況會更複雜 )。因此，我們可以用前面給出的演算
法求解剩餘的樹，並由此得到整個問題的解。當然，在一般情況下 (與地圖著色相反)為 SA選擇的值
可能是錯誤的，因此我們將需要嘗試所有的值。一般演算法如下： 

1.從 CSP變數中選擇一個子集 S，使得限制圖在刪除 S之後成為一棵樹。S稱為環割集。 
2.對於每個賦予 S中滿足所有施加於 S限制之變數的值 
(a)自剩餘數值域移走任何不相容於賦予 S之值的值，且 
(b)如果其餘的 CSP有一個解，將它隨同 S之賦值傳回。

Ch6限制滿足問題 


.6-21. 
如果環割集的大小為 
c，那麼總執行時間為 
O (dc •(n – c)d 2 )：我們必須試試每個 
S中變數的 
dc個值
的組合，且對每個組合我們必須解一個樹的大小為 
n – c的問題。如果限制圖「近似於一棵樹」，那
麼 
c將會很小，並且比直接回溯將有很大的節省。然而在最壞情況下， 
c可能大到(n – 2)。找到最小
的環割集是一個 
NP-hard，但已有若干高效率的近似演算法。總體演算法叫做割集調整；我們將在第
十四章再次見到，在那裡用來進行機率推理。

第二個方法是建立在構造限制圖的樹分解的基礎上的，它把限制圖分解為相關聯的子問題集。
每個子問題將會獨立地求解，再把得到的結果合併起來。像多數分治演算法一樣，如果沒有一個子
問題特別大，它的效果就會很好。圖 
6.13給出了地圖著色問題的樹分解，形成 
5個子問題。一個樹
分解必須滿足以下 
3個條件： 


● 
每個原始問題中的變數至少在一個子問題中出現。 
● 
如果兩個變數在原問題中由一個限制相連，那麼它們至少同時出現在同一個子問題中 
(連同它們
的限制)。 
● 
如果一個變數出現在樹中的兩個子問題中，它必須出現在連接這些子問題的路徑上的所有子問
題裡。
前兩個條件保證了所有的變數和限制都在分解中表示出來。第三個條件看起來更技術性，但是它只
是反映了任何給定的變數在每個子問題中必須取值相同的限制；子問題之間的連接強制了這個限
制。例如，在圖 
6.13中 
SA出現在連接起來的所有 
4個子問題中。你可以從圖 
6.12驗證這種分解是
有意義的。


圖 6.13 圖 6.12(a)中限制圖的樹分解


.6-22..6-22.
人工智慧 
–現代方法 
3/E

我們獨立地求解每個子問題；如果其中任何一個無解，那麼原始問題就無解。如果我們能求解
所有的子問題，接下來我們就要嘗試構造一個全局解。首先，我們把每個子問題視為一個「大變數」，
它的值域是這個子問題的所有解的集合。例如，圖 
6.13中最左邊的子問題是一個有 
3個變數的地圖
著色問題，因此有 
6個解——其中一個是{WA = red, SA = blue, NT = green}。然後我們可以用前面給
出的對樹的有效演算法來求解連接這些子問題的限制問題。對於子問題之間的限制僅僅需要保持它
們的共用變數的相容性。例如，對第一個子問題給定的解 
{WA = red, SA = blue, NT = green}，下一個
子問題的相容解只能是{SA = blue, NT = green, Q = red}。

一個給定的限制圖允許有多種樹分解；在選擇分解的時候，目標是分解出來的子問題越小越好。
圖的樹分解的樹寬比最大的子問題的大小少 
1；圖本身的樹寬定義為它所有樹分解的最小樹寬。如
果一個圖的樹寬為 
w，並且給定相對應的樹分解，那麼這個問題的時間複雜度是 
O(nd w+1)。因此，
限制圖樹寬有界的 
CSP問題是多項式時間內可解的。不幸的是，找到最小樹寬的樹分解是一個 
NP
難題，不過實際上有一些很可行的啟發式方法。

到現在為止，我們已經查看過限制圖的架構。於變數值也可能有重要的架構。考慮 
n個顏色的
地圖著色問題。對每一個相容的解答，實際上有一個經由排列顏色名稱所構成的 
n!解答集合。舉例
來說，在澳洲地圖我們知道 
WA，NT，與 
SA必須全都有不同的顏色，但是有 
3! = 6方法賦予三個顏
色於這三個區域。這稱之為為值的對稱。我們想要藉由打破對稱來縮減搜尋空間達 
n!倍。我們藉由
引進打破對稱的限制來達成目的。就我們的例子而言，我們可能會施加一個任意排序限制， 
NT < SA 
< WA，該限制要求這三個值須依字母順序來排列。這個限制確保 
n!個解答中只有一個是可能的： 
{NT 
= blue, SA = green, WA = red}。

就地圖著色而言，找出除去對稱的限制很容易，且一般而言可能在多項式量級的時間內找出能
除去所有而只有一個是對稱之解答的限制，但是於搜尋期間，要除去暫時值之集合的所有對稱則屬
於一種 
NP-hard的問題。實務上，在許多問題上，打破值的對稱性業經證明是很重要的且有效的。 


 總結 

● 
限制滿足問題 
(CSP)以變數/值對的集合來表示狀態並以施加於該變數之限制的集合來表示解答
的條件。許多重要的現實世界問題都可以描述為 
CSP問題。 
● 
有些推理技術使用限制來推論哪些變數/值對是相容的且哪些是是不相容的。這些包括節點，
邊，路徑，與 
k-相容。 
● 
回溯搜尋，深度優先搜尋的一種形式，經常用於求解 
CSP問題。推理可以與搜尋交錯運用。 
● 
最少剩餘值和度啟發式演算法是在回溯搜尋中決定下一步選擇哪個變數的兩個獨立於值域的方
法。對於一個已給定的變數，最少限制值(least-constraining-value)啟發式有助於決定該優先試哪
一個值。回溯發生在對一個變數找不到合法賦值的時候。衝突導向的後向跳躍，直接回溯到問
題的源頭。 
● 
使用最小衝突啟發式演算法的局部搜尋，在求解限制滿足問題方面，已經很成功。

Ch6限制滿足問題 


.6-23. 
● 
求解 
CSP問題的複雜度大部份上取決於限制圖的結構。樹狀結構的問題可以在線性時間內求
解。割集調整可以把一般的 
CSP問題簡化為樹狀結構，並且在能找到比較小的割集的情況下，
十分有效。樹分解技術把 
CSP問題轉變為子問題的樹，並且當限制圖的樹寬很小的時候是很有
效的。 
..參考文獻與歷史的註釋 
BIBLIOGRAPHICAL AND HISTORICAL NOTES
限制滿足問題有關的最早工作大部分是處理數值限制。整數域內方程式的限制最早在 
7世紀
由印度數學家 
Brahmagupta研究過；在希臘數學家戴奧弗多斯(Diophantus，約 
200-284)之後這
類問題常稱為戴奧弗多斯方程式(Diophantine equations)，他實際是在正有理數域內考慮了這個問
題。透過消元法解線性方程的系統方法由高斯 
(Gauss，1829)研究過；對線性不等式限制的求解方法
可追溯到傅立葉(Fourier，1827)。

有限值域的限制滿足問題也有很長的歷史。例如，圖著色問題(地圖著色是其中的一種特殊情況)
是數學史上的一個古老問題。四色問題假說(每一平面圖都可用四種或更少的顏色著色)是 
1852年由
狄摩根(de Morgan)的一個學生 
Francis Guthrie首次提出。它抗拒解答——儘管數個已刊載的文章，
是做相反的聲言——直到 
Appel與 
Haken(1977)提供了證明[請參閱 
Four Colors Suffice(Wilson，2004)
一書]。純粹理論者對於其中一部份證明須仰賴電腦來證明感到失望，所以 
Georges Gonthier(2008)，
使用 
COQ理論證明器，推導出一個正式的證明展示 
Appel與 
Haken的證明是正確的。

特定類型的限制滿足問題的出現，貫穿於電腦科學史。其中一個最有影響力的早期例子是 
SKETCHPAD系統(Sutherland，1963)，它解決了圖的幾何限制問題並且是現代繪圖程式和 
CAD工
具的先驅。把 
CSP當作一般性的問題要歸功於 
Ugo Montanari(1974)。將高階 
CSP問題透過輔助變數
簡化為純粹的二元 
CSP問題(參見習題 
6.5)，初源自 
19世紀的邏輯學家 
Charles Sanders Peirce。 
Dechter(1990b)把它納入 
CSP文獻，並由 
Bacchus和 
van Beek(1998)作了詳細描述。對解有偏好的 
CSP
問題在最佳化的文獻中有廣泛的研究；參見 
Bistarelli等人(1997)對允許偏好的 
CSP架構的一般化。
桶消除演算法(Dechter，1999)也可以用於問題最佳化。

限制傳播方法的普及歸功於 
Waltz(1975)在電腦視覺方面的多面體線性標注問題上的成功。 
Waltz
證明了在許多問題中，限制的傳播能完全消除回溯的需要。 
Montanari(1974)引入了限制網路的概念
和透過路徑相容性進行的限制傳播。Alan Mackworth(1977)提出了 
AC-3演算法，實作了增強的邊相
容以及把回溯與某種程度的強制相容結合起來的一般想法。更有效的邊相容演算法 
AC-4是由 
Mohr
和 
Henderson(1986)發展出來的。在 
Mackworth的論文出現之後不久，研究者們開始實驗研究，強制
相容的代價與由搜尋減少帶來的好處，兩者之間的折衷。 
Haralick和 
Elliot(1980)證實了 
McGregor(1979)描述的最小前向檢驗演算法，而 
Gaschnig(1979)提出了在每個變數賦值之後的完全邊
相容檢驗演算法——後來被 
Sabin和 
Freuder(1994)稱為 
MAC的演算法。後者的論文提供了令人信服
的證據，說明在更難的 
CSP問題上完全邊相容演算法是成功的。 
Freuder(1978，1982)研究了 
k相容
的概念，以及它與求解 
CSP問題的複雜度之間的關係。 
Apt(1999)描述了可以用來分析相容性傳播演
算法的一般性演算法架構，而 
(2006)提出當前的探究成果。


.6-24..6-24.
人工智慧 
–現代方法 
3/E

處理高階或全局的限制問題的特殊方法，最早是在限制邏輯程式設計的脈絡中發展出來的。 
Marriott和 
Stuckey(1998)提供了該值域的出色的綜述。 
Alldiff限制由 
Regin(1994)，Stergiou與 
Walsh(1999)，以及 
van Hoeve(2001)所研究。Van Hentenryck等人(1998)把邊界限制問題與限制邏輯
程式設計結合起來。有關全局限制方面的探討由 
van Hoeve與 
Katriel(2006)所提供。

數獨已變成最為熟知的 
CSP且被 
Simonis(2005)做如是的介紹。 
Agerbeck與 
Hansen(2008)描述一
些策略並於一個 
n2×n2板展示數獨屬於一種 
NP-hard問題。Reeson等人(2007)展示一個建立在 
CSP
技術的互動求解器。

回溯搜尋的構想可以追溯到 
Golomb與 
Baumert(1965)，且它的應用於限制滿足問題則歸功於 
Bitner與 
Reingold(1975)，儘管它們的基本演算法可回溯到 
19世紀。 
Bitner和 
Reingold也引入了 
MRV
啟發式演算法，他們稱之為最強限制變數啟發式演算法。 
Brelaz(1979)用度啟發式演算法，作為 
MRV
啟發式演算法的一個打破僵局的工具。這樣的演算法雖然簡單，但卻是任意圖 
k著色問題的最佳方
法。Haralick和 
Elliot(1980)提出了最少限制值啟發式演算法。

最基本的後向跳躍方法是由 
John Gaschnig(1977，1979)提出來的。 
Kondrak和 
van Beek(1997)證
明了這個演算法本質上包含在前向檢驗演算法中。衝突指導的後向跳躍演算法是 
Prosser(1993)發明
的。最一般也是最有效形式的聰明後向跳躍演算法其實很早就由 
Stallman和 
Sussman(1977)提出來
了。他們的依賴性指導的回溯技術，引導了真值維護系統的發展 
(Doyle，1979)，我們將在第 
12.6.2
節中討論。Kleer(1989)分析了這兩個值域之間的聯繫。 


Stallman和 
Sussman的工作還引入了限制學習的想法，透過搜尋得到的部分結果可以保存下來，
並在後面的搜尋中重新使用。該構想由 
Dechter(1990a)予以正式化。後向標記(Gaschnig，1979)是一
個特別簡單的方法，其中相容和不相容的成對賦值被保存下來，並且用來避免重複檢驗限制。後向
標記可以和衝突指導的後向跳躍演算法結合使用； 
Kondrak和 
van Beek(1977)提出了一個包含這兩種
演算法的混合演算法。動態回溯方法(Ginsberg，1993)保留了後面變數子集的成功的不完全賦值，當
回溯略過早期選擇時，不會破壞後來的成功。

數個隨機化回溯方法的實驗性研究由 
Gomes等人(2000)，以及 
Gomes與 
Selman(2001)所完成。 
Van Beek(2006)探討了回溯。

局部搜尋演算法在限制滿足問題中普及是由於 
Kirkpatrick等人(1983)在模擬退火方面的研究(參
見第四章)，它在排程問題中得到了廣泛應用。最小衝突啟發式演算法首先由 
Gu(1989)提出來以及由 
Minton等人(1992)獨立發展出來。 
Sosic和 
Gu(1994)說明了如何用之在 
1分鐘之內求解 
3百萬皇后問
題。在 
n皇后問題上應用最小衝突啟發的局部搜尋演算法上令人震驚的成功，使人們重新考慮「容
易」和「難」的問題的本質和通性。 
Peter Cheeseman等人(1991)探索了隨機產生的 
CSP問題的難度，
並發現幾乎所有這樣的問題不是極其簡單，就是就無解。只有當問題產生器的參數在一個特定的很
窄的區域裡，產生的問題才有大約一半可解，而我們能找到「難」題的實例。我們將在第七章進一
步討論這個現象。 
Konolige(1994)展示在具有某種程度的區域架構之問題的區域搜尋是不如回溯搜尋
的；這引領出結合了區域搜尋與推理的成果，如 
Pinkas與 
Dechter(1995)者。Hoos與 
Tsang(2006)探
討區域搜尋技術。


Ch6限制滿足問題 


.6-25. 
CSP問題相關的結構和複雜性研究，起源於 
Freuder(1985)，他顯示在邊相容樹上無回溯的搜尋
是可行的。用無環超圖的擴展得到了一個類似的結果 
(Beeri等人， 
1983)。Bayardo與 
Miranker(1994)
展示了針對樹狀架構之 
CSP的演算法，它在沒有任何預處理的程序下，執行時間會是線性的。

由於這些論文的發表，在求解 
CSP問題的複雜性和該問題限制圖結構之間的聯繫上，有了許多
更廣泛的研究進展。圖論家 
Robertson和 
Seymour(1986)引入了樹寬的概念。Dechter和 
Pearl(1987， 
1989)在 
Freuder的研究基礎上，把同樣的概念應用於限制滿足問題 
(他們稱之為歸納寬度)，同時展出
第 
6.5節中描述的樹分解方法。利用這些知識和資料庫理論的結果， 
Gottlob等人(1999a，1999b)提出
了超樹寬的概念，它建立在把 
CSP問題刻畫為一個超圖的基礎上。除證明了任何超樹寬為 
w的 
CSP
問題可以在 
O(nw+1log n)時間內求解以外，他們還證明了在超樹寬有界而其他度量無界的情況下，超
樹寬包容了所有先前定義的「寬度」度量。

對於將回看(look-back)方法運用於回溯的興趣被 
Bayardo與 
Schrag(1997)的成果所重新點燃，他
的 
RELSAT演算法結合了限制學習與後向跳躍，並且展示了時間上優於許多其他演算法。這引領出
可同時應用於 
CSP與機率性推理的 
AND/OR搜尋演算法 
(Dechter與 
Mateescu，2007)。Brown等人 
(1988)引進打破 
CSP中對稱的構想，而 
Gent等人(2006)提供了最近的探討成果。

分散式限制滿足領域探討的是，當有一群代理人，每個人控制一部分限制變數，如何求解 
CSP。
從 
2000年起關於這個問題已經舉行了年度講習，以及好文章 
(Collin等人， 
1999；Pearce等人， 
2008； 
Shoham與 
Leyton-Brown，2009)。 


CSP演算法的多屬於實驗性的科學：很少有理論的結果能證明在所的問題上，某個演算法會優
於另一個演算法；相反的，我們必須實驗看看於典型問題的實例上哪一種演算法表現的比較好。如
同 
Hooker(1995)指出的，我們必須小心的辨別各個爭出鋒頭的測試之間有何不同 
——如同出現在演
算法以執行時間來互爭高下 
——以及科學性的測試，它的目標是辨認出的演算法特性，此特性可用
於決定在某類型問題上它的效率。

由 
Apt(2003)與 
Dechter(2003)新近出版的教科書，以及 
Rossi等人(2006)的彙編都是限制處理的
極佳資源。關於 
CSP技術有很多好的介紹，包括 
Kumar(1992)，Dechter和 
Frost(2002)，Bartak(2001)
的；還有由 
Dechter(1992)和 
Mackworth(1992)寫的百科全書式的文章。Pearson和 
Jeavons(1997)綜述
了 
CSP中可操作的問題，涵蓋了結構分解方法和依賴於值域或限制本身屬性的方法。 
Kondrak和 
van 
Beek(1997)給出了回溯搜尋演算法的一個分析性綜述，而 
Bacchus和 
van Run(1995)給出了一個更加
經驗化的概述。限制程式的設計涵蓋於 
Apt(2003)與 
Fruhwirth與 
Abdennadher(2003)所寫的書。在 
Freuder和 
Mackworth(1994)編輯的論文集中，描述了 
CSP問題的幾個有趣的應用。關於限制滿足問
題的論文通常出現在《人工智慧》 
(Artificial Intelligence)和專業期刊《限制》 
(Constraints)上。這一值
域主要的會議是「限制規劃理論與實踐國際會議」(International Conference on Principles and Practice of 
Constraint Programming)，通常簡稱為 
CP。


.6-26..6-26.
人工智慧 
–現代方法 
3/E 


.習題 
EXERCISES 

6.1 
圖 
6.1所示的地圖著色問題一共有多少個解？如果可允許四種顏色，則會有多少解答？兩種
顏色呢？ 
6.2 
考慮將 
k個騎士放到一個 
n×n棋盤使得任兩個騎士不會互相攻擊的問題，其中 
k已知且 
.2。
kn

6.3 
考慮一個構造(不是求解)縱橫字謎的問題[5]：將詞填入矩形的格子中。作為問題的一個部分，
矩形格子指定了哪些方格是空的，哪些是有陰影的。假設給定了一個單詞清單 
(也就是一個詞
典)，任務是用單詞清單的任何子集來填充空格。用以下兩種方法精確地形式化這個問題： 
a. 
形式化為一般的搜尋問題。選取一個適合的搜尋演算法併指明一個啟發式函數。每次將一
個字母填入空格會是比較好的做法或是每次一個字？ 
b.形式化為一個限制滿足問題。問題的變數應該是字母還是單詞？
你認為這兩種形式化的方法哪種更好？為何？ 
6.4 
對以下兩個問題給出精確的限制滿足問題的形式化： 
a. 
直線性的樓面規劃：在一個大的矩形裡找到不重疊位置供許多小矩形放置。 
b. 
授課日程安排：給定了固定數量的教授和教室，一個可提供課程的清單，以及可能安排課
程的時間段清單。每個教授有他(或她)能教的課程列表。 
c. 
漢密頓周遊：給予一個由馬路連接所形成的城市網路，選擇不會重複拜訪某個國家中的所
有城市的順序。 
6.5 
分別用回溯演算法、前向檢驗演算法、 
MRV和最少限制值啟發式演算法手工求解圖 
6.2中的
密碼算術問題。 
6.6 
說明如何透過使用一個輔助變數把一個諸如「A+ B= C」這樣的三元限制問題轉變成三個二
元限制。可以假設值域是有限的。 
(提示：考慮一個取自那些值與其它值成對的新變數，並考
慮限制如「 
X是 
Y對的第一個元素。」 
)接著，展示三個以上變數的限制如何可以相似的方法
來處理。最後，說明如何透過改變變數的值域來消除一元限制。這就完整展示了任何 
CSP問
題都可以轉變為只使用二元限制的 
CSP。 
6.7 
考慮下述的邏輯問題：有 
5所不同顏色的房子，住著 
5個來自不同國家的人，每個人都喜歡
一種不同牌子的香煙、不同牌子的飲料和不同的寵物。給定下列已知條件，請回答問題「斑
馬住在哪兒？以及哪所房子裡的人喜歡喝水？ 
● 
英國人住在紅色的房子裡。 
● 
西班牙人養的是狗。 
● 
挪威人住在最左邊的第一所房子裡。 
● 
綠色屋子就在象牙屋的右邊。 
● 
喜歡抽 
Chesterfields牌香煙的人住在養狐狸的人的旁邊。 
● 
Kit Kat在黃色房子中被吃掉。 
● 
挪威人住在藍色房子旁邊。 
● 
吃 
Smarties的人擁有蝸牛。

Ch6 
限制滿足問題 


.6-27. 
●吃 
Snickers的人喝柳橙汁。 
●烏克蘭人喜歡喝茶。 
●日本人吃 
Milky Way。 
● Kit Kat緊挨著豢養馬匹房子的房子中被吃掉。 
●住綠色屋子的人喜歡喝咖啡。 
●住在中間房子裡的人喜歡喝牛奶。
討論把這個問題表示成 
CSP問題的不同表示法。你認為哪種比較好，為什麼？ 


6.8 
考慮具有 
8個節點的圖形 
A1，A2，A3，A4，H，T，F1，F2。對所有的 
i，Ai連接至 
Ai+1，每個 
Ai連接至 
H，H連接至 
T，而 
T連接至每個 
Fi。使用下述策略以手算的方式找出這張圖的三
個顏色：以衝突導向的後向跳躍做回溯，變數的順序是 
A1，H，A4，F1，A2，F2，A3，T，與
值的順序是 
R，G，B。 
6.9 
解譯為什麼在 
CSP搜尋中，一個好的啟發式演算法選擇變數的時候應該選擇限制最多的變
數，而選擇值的時候應該選擇造成限制最少的。 
產生地圖著色問題的隨機實例如下：將 
n個點分散到單位正方形上；隨機地選擇點 
X，將 
X與距離最近的點 
Y用直線段連接起來，之前 
Y必須沒有和 
X相連，它們的連線也不
能跨越已有的連線；重複前面的過程直到不再有可能的連接。點代表地圖上的區域且直線連
接鄰近的區域。現在對 
k = 3與 
k = 4試著找出每張地圖的 
k個顏色，使用最小衝突，回溯，
具前向檢驗之回溯，具 
MAC之回溯。針對每個演算法，建立一張平均執行時間表格，數值
從 
n到你所能掌握的最大值。評論你的結果。 


6.10

6.11 
用 
AC-3演算法說明邊相容對圖 
6.1中所示問題能夠檢測出不完全賦值{WA = red, V = blue}的
不相容。 
6.12 
在樹狀結構 
CSP問題的最壞情況下執行 
AC-3演算法的複雜度是多少？ 
6.13 
AC-3演算法在從 
Xi的值域中刪除任何值時，都把每條邊(Xk, Xi)放回到佇列裡，即使 
Xk中的
每個值都和 
Xi的一些剩餘值相容。假設對每條邊 
(Xk, Xi)，我們記錄 
Xi與 
Xk中的每個值都相容
的剩餘值的個數。解譯如何有效地更新這些數字，並因此使邊相容演算法時間複雜度為 
O(n2d2)。 
6.14 
TREE-CSP-SOLVER(圖 
6.10)從葉節點開始讓邊相容並反方向朝根節點進行。它為什麼會這樣
做？如果它朝相反的方向走，會發生什麼後果？ 
6.15 
我們引進數獨並視之為一個準備透過搜尋一部份的賦值來予以解出的 
CSP，因為這是一般人
求解數獨問題的方式。當然，也有可能以區域搜尋全部賦值的方式來求解這些問題。一個使
用最小衝突啟發式的區域求解器在數獨問題上會表現的多好？ 
6.16 
以你自己的話來定義限制，可交換性，邊相容，後向跳躍，最小衝突，與環割集。

.6-28..6-28.
人工智慧 
–現代方法 
3/E 



假設已知一含有不超過 
k個節點的環割集的圖。描述一個尋找最小環割集的簡單演

算法，它的執行時間在 
n個變數的 
CSP問題中不超過 
O(nk)。在參考文獻中查閱在割集大小

的多項式時間內能完成尋找近似最小環割集的方法。現有的演算法能使環割集方法實用嗎？

本 章 註 腳 
[1] AC-4演算法(Mohr與 
Henderson，1986)最壞情況下的執行時間是 
O(cd2)但是在平均情況下可能
會略慢於 
AC-3。(參見習題 
6.12)。 
[2]局部搜索很容易擴展限制最佳化問題(COP)。如果那樣的話，爬山法和模擬退火的所有技術都可
以用來最優化目標函數。 
[3]一個細心的繪圖者或 
Tasmanian的熱愛者可能會反對把 
Tasmania塗上和離它最近的大陸鄰域相
同的顏色，以避免別人認為 
Tasmanian可能是那個州的一部分。 
[4]令人難過的是,世界上有非常少的區域具有樹狀架構化的地圖，儘管 
Sulawesi已是非常接近了。 
[5] Ginsberg等人(1990)討論過幾種構造縱橫字謎的方法。 
Littman等人(1999)討論了更難的問題，如
何求解縱橫字謎問題。


